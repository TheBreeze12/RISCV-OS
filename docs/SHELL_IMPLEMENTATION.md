# Shell 实现指南

## 已实现的功能

### 1. 系统调用层
- ✅ `sys_exec` 系统调用已实现
  - 从用户空间读取程序路径
  - 从用户空间读取参数数组（argv）
  - 调用内核的 `exec()` 函数执行程序

### 2. Shell 层
- ✅ 命令行解析
- ✅ 内置命令执行
- ✅ 外部程序执行（fork+exec模式）
- ✅ 错误处理

## 如何使用

### 执行外部程序

在shell中输入程序路径即可执行：

```bash
$ /init
# 或者
$ init
```

### 执行带参数的程序

```bash
$ /init arg1 arg2 arg3
```

## 当前限制

### 1. 文件系统限制

当前文件系统（`kernel/fs/namei.c`）只支持查找 `/init` 或 `init` 程序。要支持更多程序，需要：

1. **扩展 `namei()` 函数**：
   - 支持查找多个程序
   - 可以维护一个程序注册表
   - 或者实现真正的文件系统

2. **示例扩展方案**：
```c
struct file* namei(char *path) {
    // 支持多个程序
    if(strcmp(path, "/init") == 0 || strcmp(path, "init") == 0) {
        // 返回init程序
    } else if(strcmp(path, "/test") == 0 || strcmp(path, "test") == 0) {
        // 返回test程序
    }
    // ...
}
```

### 2. 程序注册

要添加新程序到系统中：

1. **编译程序为ELF文件**
2. **将ELF数据嵌入内核**（类似 `initcode.h`）
3. **在 `namei()` 中添加查找逻辑**

## 实现真正的Shell需要做什么

### 必须完成（核心功能）

1. ✅ **sys_exec 系统调用** - 已完成
2. ✅ **Shell的fork+exec逻辑** - 已完成
3. ⚠️ **文件系统扩展** - 需要支持多个程序

### 可选增强

1. **后台执行** (`&`)
   - 不等待子进程完成
   - 管理后台任务列表

2. **管道** (`|`)
   - 进程间通信
   - 重定向输入输出

3. **重定向** (`>`, `<`)
   - 文件输入输出重定向

4. **环境变量**
   - PATH变量支持
   - 自动查找程序路径

5. **通配符** (`*`, `?`)
   - 文件名匹配

6. **命令历史**
   - 保存和回放命令

## 测试建议

1. **测试内置命令**：
   ```bash
   $ help
   $ echo hello world
   $ pid
   ```

2. **测试外部程序**：
   ```bash
   $ /init
   $ init
   ```

3. **测试错误处理**：
   ```bash
   $ /nonexistent
   # 应该显示错误信息
   ```

## 下一步

要实现完整的shell功能，建议按以下顺序：

1. **扩展文件系统** - 支持多个程序
2. **添加PATH支持** - 自动查找程序
3. **实现后台执行** - 提升用户体验
4. **添加管道和重定向** - 增强功能

