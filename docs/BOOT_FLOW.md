# 最小RISC-V操作系统启动流程

## 启动流程图

```
QEMU启动
    ↓
[硬件复位] PC = 0x80000000
    ↓
[entry.S] _start:
    ├─ 输出调试字符 'S' (启动标记)
    ├─ 设置栈指针 sp = stack_top
    ├─ 输出调试字符 'P' (栈设置完成)
    ├─ 清零BSS段 (如果需要)
    └─ 跳转到C主函数 main()
    ↓
[main.c] main():
    ├─ UART初始化
    ├─ 输出启动信息
    ├─ 基础内存管理初始化(可选)
    └─ 进入主循环
    ↓
[主循环]
    └─ 等待中断/简单交互
```

## 关键问题分析

### 1. 栈位置和大小
**位置选择**：
- 放在内核镜像结束后的高地址区域
- 避免与内核代码/数据重叠
- 建议地址：0x80100000 (内核后1MB处)

**大小考虑**：
- 最小系统：4KB (1页) 足够
- 支持递归调用：8KB-16KB 较安全
- 多核系统：每个核心独立的栈

### 2. BSS段清零
**是否需要**：是，必须清零
**原因**：
- C语言标准要求未初始化全局变量为0
- 编译器生成的代码依赖这个假设
- 避免随机值导致的不可预测行为

### 3. 最简串口输出配置
**UART基地址**：0x10000000 (QEMU virt机器)
**必需寄存器配置**：
- THR (Transmit Holding Register): 数据发送
- LSR (Line Status Register): 状态检查
- 可选：波特率、数据位等(QEMU默认配置通常可用)

## 内存布局方案

```
高地址
┌─────────────────┐ 0x88000000 (PHYSTOP)
│   可用内存      │
├─────────────────┤ 0x80200000
│   栈区域        │ ← 栈顶
│   (向下增长)    │
├─────────────────┤ 0x80100000 (stack_top)
│   堆区域        │
│   (预留)        │
├─────────────────┤
│ .bss 段         │ ← 需要清零
├─────────────────┤
│ .data 段        │ ← 已初始化数据
├─────────────────┤
│ .rodata 段      │ ← 只读数据
├─────────────────┤
│ .text 段        │ ← 代码段
└─────────────────┘ 0x80000000 (KERNBASE)
低地址
``` 